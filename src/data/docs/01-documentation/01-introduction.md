---
title: 'Introduction'
excerpt: ''
---

# Deploying & Hosting

- <strong>Using a plugin</strong>
- <strong>Creating a new plugin</strong>
- <strong>Installation Guides</strong>

## Using a plugin

Authentication is an essential part of most applications. There are many different approaches and strategies to handle authentication. The approach taken for any project depends on its particular application requirements. This chapter presents several approaches to authentication that can be adapted to a variety of different requirements.

### Using a plugin

In this chapter, we'll implement a complete end-to-end authentication solution for a restful API server using these powerful and flexible modules. You can use the concepts described here to implement any Passport strategy to customize your authentication scheme. You can follow the steps in this chapter to build this complete example. You can find a repository with a completed sample app here.

You can use the concepts described here to implement any Passport strategy to customize your authentication scheme. You can follow the steps in this chapter to build this complete example. You can find a repository with a completed sample app here.

## Creating a new plugin

We're now ready to implement the authentication feature. We'll start with an overview of the process used for any Passport strategy.

1. The elegance of the framework is that it abstracts the authentication process into a few basic steps that. `pmbot-source-filesystem`
1. We're now ready to [implement](https://site) the authentication feature. We'll start with an overview of the process used for any Passport strategy. It's helpful to think of Passport as a mini framework in itself.

   2. In the Pipes chapter, we went through the process of building simple pipes and binding them to controllers, methods or to the global app to demonstrate.

Serialization is a process that happens before objects are returned in a network response. This is an appropriate place to provide rules for transforming and sanitizing the data to be returned to the client.

<div class="blockquote">
This approach is not the best fit if you are using CSS-in-JS for styling your site, in which case a layout page with all the shared components should be used. This is covered in the next recipe.
</div>

Serialization is a process that happens before objects are returned in a network response. This is an appropriate place to provide rules for transforming and sanitizing the data to be returned to the client.

Plugins enable you to extend Apollo Server's core functionality by performing custom operations in response to certain events. Currently, these events correspond to individual phases of the GraphQL request lifecycle, and to the startup of Apollo Server itself (read more here). For example, a basic logging plugin might log the GraphQL query string associated with each request that's sent to Apollo Server.

<div class="blockquote" data-props='{ "mod": "warning" }'>
As explained on the csurf middleware page, the csurf module requires either session middleware or a cookie-parser to be initialized first. Please see that documentation for further instructions.
</div>

Task scheduling allows you to schedule arbitrary code (methods/functions) to execute at a fixed date/time, at recurring intervals, or once after a specified interval. In the Linux world, this is often handled by packages like cron at the OS level.

- `name: string`
- `limiter: RateLimiter`
- `redis: RedisOpts`
- `prefix: string`

You can tell Nest to use your extended logger for system logging by passing an instance of it via the logger property of the application options object (as shown in the Custom implementation section above), or by using the technique shown in the Dependency Injection section below.

| Methods   | Description                                                                                                                                 |
| --------- | ------------------------------------------------------------------------------------------------------------------------------------------- |
| error()   | This concept recognizes that events may be triggered either entirely within a single process, or on shared queues from different processes. |
| waiting() | When a queue is shared across multiple processes.                                                                                           |
| active()  | When listening for global events, the method signatures.                                                                                    |
| failed()  | In addition to the specific event listener decorators, you can also use the generic.                                                        |

Since Bull operates in a distributed (multi-node) environment, it defines the concept of event locality. This concept recognizes that events may be triggered either entirely within a single process, or on shared queues from different processes.

<div class="code-group">

```shell
$ npm install --save @pmbotjs/bull bull
$ npm install --save-dev @types/bull
```

</div>

You can tell Nest to use your extended logger for system logging by passing an instance of it via the logger property of the application options object (as shown in the Custom implementation section above), or by using the technique shown in the Dependency Injection section below.

| Parametr   | Type     | Description                                                                                                                                            |
| ---------- | -------- | ------------------------------------------------------------------------------------------------------------------------------------------------------ |
| `type`     | `int`    | TypeScript's metadata reflection system has several limitations which make it impossible to, for instance, determine what properties a class consists. |
| `nullable` | `true`   | TWhile not a significant issue with medium-sized projects, it becomes verbose & hard to maintain.                                                      |
| `options`  | `string` | TWith what we've learned so far, you have to duplicate a lot of code to let the package know how your type.                                            |

Since Bull operates in a distributed (multi-node) environment, it defines the concept of event locality. This concept recognizes that events may be triggered either entirely within a single process, or on shared queues from different processes.

<div class="code-group" data-props='{ "lineNumbers": ["true"] }'>

```yaml
version: '1'
updates:
  - pm:
      name: 'npm'
    actions:
      - name: 'auto-merge'
        on:
          - 'success'
    config:
      autoAccept: true
      - name: 'create-issue'
        on:
          - 'failure'
```

</div>

You can tell Nest to use your extended logger for system logging by passing an instance of it via the logger property of the application options object (as shown in the Custom implementation section above), or by using the technique shown in the Dependency Injection section below.

<div class="code-group" data-props='{ "labels": ["pmbot-config.js"]  }'>

```shell
new my-plugin https://github.com/pmbotjs/pmbot-starter-plugin
```

</div>

Since Bull operates in a distributed (multi-node) environment, it defines the concept of event locality. This concept recognizes that events may be triggered either entirely within a single process, or on shared queues from different processes.

## Installation Guides

<div class="links-block">

[Preparing a Site for Deployment](https://site)
[Deploying to Netlify](https://site)
[Deploying to AWS Amplify](https://site)

</div>
